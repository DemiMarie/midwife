#include "lexer.hpp"
#include <string>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <cerrno>
#include <cassert>
#include <cstdio>
#define INDEX(n) (input[n] - '0')
//#define YYFILL(n) die("internal error (this is a bug)\n");
/*!re2c
  re2c:define:YYCTYPE     = "char";
  re2c:cond:goto          = continue;
  re2c:define:YYCURSOR    = input;
  re2c:define:YYLIMIT     = end;
  re2c:define:YYMARKER    = marker;
  re2c:indent:top         = 1;
  re2c:indent:string      = "    ";
  re2c:yyfill:enable      = 0;
*/
bool error(const char *msg) {
  fprintf(stderr, "Syntax error for input '%s'\n", msg);
  exit(127);
}
stringVector lexer (char *input, size_t argc, char ** argv) {
  fputs(input, stderr);
  stringVector buffer = std::vector<std::string>(1);
  std::string *ptr = buffer.data();
  const char *const end = input + strlen(input);
  bool split = true;
  char *marker = (char *)0xAEFDC;
  while (true) {
    /*!re2c
    "\\x"[0-9a-fA-F][0-9a-fA-F] {
      const char temp = input[4];
      input[4] = '\0';
      ptr->push_back(strtoul(input + 2, 0, 16));
      input[4] = temp;
    }
    "\\" [0-3][0-7][0-7] {
      ptr->push_back(INDEX(3) + 8*(INDEX(2) + 8 * INDEX(1)));
    }
    "\\" [$"\\]  { ptr->push_back(input[1]); }
    "\\n"      { ptr->push_back('\n'); continue; }
    "\\t"      { ptr->push_back('\t'); continue; }
    "\\v"      { ptr->push_back('\v'); continue; }
    "\\f"      { ptr->push_back('\f'); continue; }
    "\\r"      { ptr->push_back('\r'); continue; }
    "\\a"      { ptr->push_back('\a'); continue; }
    "\\b"      { ptr->push_back('\b'); continue; }
    "${"[0-9]+"}" {
      errno = 0;
      unsigned long value = strtoul(input + 2, 0, 10);
      if (0 == errno && argc > value) {
        ptr->operator += (argv[value]);
      }
      continue;
    }
    "$"[0-9] {
      unsigned char value = input[1] - '0';
      if (argc > value) {
        ptr->operator += (argv[value]);
      }
      continue;
    }
    "$@" {
      ptr->operator += (argv[0]);
      for (size_t i = 1; i < argc; ++i) {
        buffer.push_back(argv[i]);
      }
      ptr = &buffer.back();
      continue;
    }
    [$\\] {
      error(input);
    }
    ["] { split = ~split; continue; }
    "\000" {
      if (split) {
        return buffer;
      } else {
        error(input);
      }
    }

    [ \t] {
      switch (input[1]) {
        default: if (split) {
          buffer.push_back(std::string());
          ptr = &buffer.back();
          break;
        }
        case '\t':
        case '\000':
        case ' ': ptr->push_back(*input);
      }
      continue;
    }
    [^] { ptr->push_back(yych); continue; }
    */
  }
  die("unreachable (this is a bug)\n");
}
/*
 * Local Variables:
 * mode: c++
 * coding: utf-8
 * End:
 */
